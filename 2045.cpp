//Problem Description
//人称“AC女之杀手”的超级偶像LELE最近忽然玩起了深沉，这可急坏了众多“Cole”（LELE的粉丝, 即"可乐"）, 经过多方打探，某资深Cole终于知道了原因，原来，LELE最近研究起了著名的RPG难题:
//有排成一行的ｎ个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要求任何相邻的方格不能同色，且首尾两格也不同色．求全部的满足要求的涂法.
//以上就是著名的RPG难题.
//如果你是Cole, 我想你一定会想尽办法帮助LELE解决这个问题的; 如果不是, 看在众多漂亮的痛不欲生的Cole女的面子上, 你也不会袖手旁观吧 ?
//
//Input
//输入数据包含多个测试实例, 每个测试实例占一行, 由一个整数N组成，(0 < n <= 50)。
//
//Output
//对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。
/*设满足PRG要求的x个方格的涂法为f(x)，求n个方格的涂法.
按照相邻颜色不同的要求染色，染到第n(n >= 4)格，第n格的情况有两种
①第n - 1个方格的颜色与第1个方格不同, 相邻颜色不同, 那么从1到n - 1满足RPG涂色的要求，涂法为f(n - 1), 在此种情况下, 第n个方格和第n - 1相邻, 涂法不同, 那么第1个, 第n - 1个, 第n个颜色都必须不同, 第n格只能是除了第1格, 第n - 1格外的颜色, 故总的可能为f(n - 1) * 1
②第n - 1个方格的颜色和第1个方格相同, 相邻颜色不同, 那么第n - 2格和第1格的颜色就不同, 从1到n - 2满足RPG要求, 涂法为f(n - 2), 第n格的要求为, 与n - 1格不同, 与第1格不同, n - 1格和第1格一同一个颜色，那么第n格剩下2种颜色可选.故总的可能有f(n - 2) * 2
综上, f(n) = f(n - 1) + 2 * f(n - 2)(n >= 4)
初值为f(1) = 3, f(2) = 6, f(3) = 6.*/
#include "problem.h"
#include <iostream>
using namespace std;

long long* getColor(int n) {
	long long* p = new long long[n+1];
	p[1] = 3;
	p[2] = 6;
	p[3] = 6;
	for (int i = 4; i <= n; i++)
		p[i] = p[i - 1] + 2 * p[i - 2];
	return p;
}
void problem2045() {
	int n;
	long long* p = getColor(50);
	while (cin >> n)
		cout << p[n] << endl;
}